{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fswiss\fcharset0 Arial;}{\f1\fnil\fcharset0 Courier New;}{\f2\fnil\fcharset0 Arial;}{\f3\fnil Arial;}}
{\colortbl ;\red0\green0\blue0;}
{\*\generator Msftedit 5.41.15.1515;}\viewkind4\uc1\pard\f0\fs20 #purpose of this R script is to take an input shapefile of points\par
#and randomly move the points a specified distance\par
#and output the corresponding shapefile and KML file\par
#Programmed in R2.13.0 for Windows XP\par
#by Gwen LaSelva, June 2011\par
\par
#eventually, add features to keep the points within an area\par
#and to make the distance the point is moved depend on population density\par
#non default libraries needed: sp, rgdal to read in shapefile\par
#tcktk and svDialogs for GUI\par
\par
#load default libraries. Need this to run as batch.\par
#currently requires shapefiles to be in lat/long\par
#might want to look at function spTransform() to change projection if needed\par
\par
\f1 library(datasets)\par
library(utils)\par
\par
setWindowTitle(":  NYSDOH Point Pertubation Tool") #adds this as a suffix to the usual window title\par
\par
setStatusBar("NYSDOH Point Pertubation Tool is running.  Please wait for dialogs.")\par
\par
\par
library(grDevices)\par
library(graphics)\par
library(stats)\par
library(methods)\par
#library(gpclib) #in case not automaticaly loaded\par
if(exists("gpclibPermit")==TRUE)\{gpclibPermit()\} #might be disabled by default, this enables it\par
library(svDialogs) #for guiDlgOpen, it needs svMisc\f0\par
\f1 library(rgdal)\par
library(tcltk)\par
#tclRequire("BWidget")\par
step<-1\par
\par
###########################################################################\par
#custom dialog function to input distance (free text) and distance units (from dropdown)\par
#uses R package tclTk\par
#list of function arguments: gattitle, gatmessage,gathelpfile,gatdefault\par
#fuction returns eiether "go back" or free text, and data field selection, and unit selection\par
#\tab (3 items)\par
###############################################################################\par
#this function from /pkg/svMisc/R/TempEnv.R, needed for gatgui and gatInput functions\par
TempEnv <-\par
function() \{\par
    pos <-  match("TempEnv", search())\par
    if (is.na(pos)) \{ # Must create it\par
        TempEnv <- list()\par
        attach(TempEnv, pos = length(search()) - 1)\par
        rm(TempEnv)\par
        pos <- match("TempEnv", search())\par
    \}\par
    return(pos.to.env(pos))\par
\}\par
gatInput<-function(gattitle="GAT input window",gathelpfile=paste("file://",getwd(),"/help/Point Random Pertubation Tool help.htm",sep=""),\par
\tab gatdefault="default text",gatmessage="Please enter something in the box",dd1choices=c("NONE","some"),dd2choices=c("m","km","mi"))\{\par
#use this function for free text input, like the minimum values\par
assign("res.inbox",value=character(0),envir=TempEnv())\par
assign("res2.inbox",value=dd1choices[1],envir=TempEnv())\par
assign("res3.inbox",value=dd1choices[1],envir=TempEnv())\par
\par
    inbox <- tktoplevel()\par
    tktitle(inbox) <- gattitle\par
    wlabel <- tklabel(inbox, text = gatmessage)\par
    varText <- tclVar(gatdefault)\par
    wtext <- tkentry(inbox, width = "20", textvariable = varText)\par
    onOk <- function() \{\par
\tab   \f0 fav <- tclvalue(dd1pick)\par
\tab     worst <- tclvalue(dd2pick)\f1\par
        assign(".res.inbox",value=tclvalue(varText),envir=TempEnv())\par
\tab   assign(".res2.inbox",value=fav,envir=TempEnv())\par
\tab   assign(".res3.inbox",value=worst,envir=TempEnv())\par
        tkdestroy(inbox)\par
        return(res.inbox)\par
    \}\par
    onCancel<-function()\{tkdestroy(inbox);quit(save="no")\}\par
    OnBack<-function()\{\par
    assign(".res.inbox", "go back", envir = TempEnv())\par
    tkdestroy(inbox)\}\par
    OnHelp <- function()\{browseURL(gathelpfile)\}\par
    #butFrame <- tkframe(inbox)\par
    wbutOK <- tkbutton(inbox, text = "  Next>  ", width = "12", command = onOk, \par
        default = "active")\par
    #wlabSep <- tklabel(butFrame, text = " ")\par
    wbutCancel <- tkbutton(inbox, text = "Cancel", width = "12", \par
        command = onCancel)\par
\par
help.but <- tkbutton(inbox,text="  Help  ",width=12,command=OnHelp)\par
back.but <- tkbutton(inbox,text=" <Back  ",width=12,command=OnBack)\par
\par
dd1pick<-tclVar(dd1choices[1]) #default selection is first in list\par
tl1 <- ttkcombobox(inbox, values=dd1choices, textvariable=dd1pick, state="readonly") \par
\par
dd2pick <- tclVar(dd2choices[1]) #default selection is first in list\par
tl2 <- ttkcombobox(inbox, values=dd2choices, textvariable=dd2pick, state="readonly") \par
\par
label1<-tklabel(inbox,text="or get maximum distance from data:")\par
label2<-tklabel(inbox,text="units:")\par
    tkgrid(wlabel, column=0,row=0,sticky = "w", padx = 5, pady = 5) #label above free entry box\par
    tkgrid(wtext, column=0,row=1,sticky="e",padx = 5, pady = 5)\par
    tkgrid(label1, column=1,row=1, sticky="e",padx = 5, pady = 5) #text label for dropdown\par
    tkgrid(tl1,column=2,row=1, sticky="w",padx = 5, pady = 5)#dropdown\par
\par
    tkgrid(label2,column=0,row=2, sticky="e", padx=5, pady=5) #select units text\par
    tkgrid(tl2, column=1,row=2,sticky="w", padx=5, pady=5) #select units dropdown\par
\par
    tkgrid(back.but,column=0,row=4,sticky = "e",padx=5,pady=5) #add extra buttons\par
    tkgrid(wbutOK,column=1,row=4,sticky = "w",padx=5,pady=5) #add extra buttons\par
    tkgrid(wbutCancel,column=2,row=4,sticky = "w",padx=5,pady=5) #add extra buttons\par
    tkgrid(help.but,column=3,row=4,sticky = "e",padx=5,pady=5) #add extra buttons\par
\par
    #tkgrid(butFrame, pady = 5,padx=5)\par
\par
\par
    #for (row in 0:2) tkgrid.rowconfigure(inbox, row, weight = 0)\par
    #for (col in 0:0) tkgrid.columnconfigure(inbox, col, weight = 0)\par
    .Tcl("update idletasks")\par
    tkwm.resizable(inbox, 0, 0)\par
    tkbind(inbox, "<Return>", onOk)\par
    tkwm.deiconify(inbox)\par
    tkfocus(wtext)\par
    tkselection.from(wtext, "0")\par
    tkselection.to(wtext, as.character(nchar(gatdefault)))\par
    tkicursor(wtext, as.character(nchar(gatdefault)))\par
    tkwait.window(inbox)\par
    res<-get(".res.inbox", envir=TempEnv(), inherits=FALSE)\par
    res2<-get(".res2.inbox", envir=TempEnv(), inherits=FALSE)\par
    res3<-get(".res3.inbox",envir=TempEnv(), inherits=FALSE)\par
    remove(res.inbox,envir=TempEnv(),inherits=FALSE)\par
    remove(res2.inbox,envir=TempEnv(),inherits=FALSE)\par
    remove(res3.inbox,envir=TempEnv(),inherits=FALSE)\par
    choices=c(res,res2,res3)\par
    return(choices)\par
\}#end gatInput function\par
#####################################################################\par
#end custom dialog function\par
####################################################################\par
\par
\par
while(step<100)\{#get user input until finalized\par
##prompt user for point file\par
if(step==1)\{setStatusBar(paste("NYSDOH Point Pertubation Tool: Looking for point file."))\par
\par
userfile<-guiDlgOpen(title = "Select Shapefile of Points to move", defaultFile = "pointstomove_point.shp", defaultDir = getwd(), multi=FALSE, filters=c("Shapefiles (*.shp)","*.shp"))\par
if(length(userfile)==0)\{quit(save="no")\} #this will happend if you hit cancel\par
\par
#remove extension if present\par
periodloc<-regexpr(".",userfile,fixed=TRUE) #will be -1 if no match, otherwise location(s) of matches\par
if(periodloc>0)\{userfile<-substr(userfile,1,periodloc[1]-1)\}\par
\par
checkfile=file.access(paste(userfile,".shp",sep=""),mode=4) #-1 for bad, 0 for OK\par
\par
if(checkfile==0)\{#found shapefile\}\par
#if found good shapefile\par
\}else\{#else needs to be on the same line as bracket so R knows the statement continues\par
print("Sorry, couldn't find point shapefile")\par
guiDlgMessage("Sorry, couldn't find your point shapefile", title = "File error",type="ok",icon="error")\par
quit(save="no")\par
\}##end prompt user for point file\par
\par
#get point file\par
#find input file name and path\par
slashloc=max(unlist(gregexpr("/",userfile,fixed=TRUE))) #find location of last slash, divides path and file name\par
userfilein<-substr(userfile,slashloc+1,nchar(userfile))\par
userpathin<-substr(userfile,1,slashloc-1)\par
\par
mypoints.shp<-readOGR(dsn=userpathin,layer=userfilein) #reads it in as spatialpolygonsdataframe with projection information\par
#get a list of all numeric fields\par
listitems<-names(mypoints.shp@data)\par
listtype<-sapply(mypoints.shp@data,class)\par
listtype[listtype=="factor"]<-FALSE\par
listtype[listtype=="character"]<-FALSE\par
listtype[listtype=="integer"]<-TRUE\par
listtype[listtype=="numeric"]<-TRUE\par
numlistitems<-listitems[listtype==TRUE]\par
\par
##prompt user for boundary file within which to keep points when they are moved\par
setStatusBar(paste("NYSDOH Point Pertubation Tool: Looking for boundary file."))\par
\par
userfileb<-guiDlgOpen(title = "Select Shapefile of boundaries to keep points in", defaultFile = "\f0 ALBA2010m_region\f1 .shp", defaultDir = getwd(), multi=FALSE, filters=c("Shapefiles (*.shp)","*.shp"))\par
\par
if(length(userfileb)==0)\{quit(save="no")\}\par
#remove extension if present\par
periodloc<-regexpr(".",userfileb,fixed=TRUE) #will be -1 if no match, otherwise location(s) of matches\par
if(periodloc>0)\{userfileb<-substr(userfileb,1,periodloc[1]-1)\}\par
\par
checkfile=file.access(paste(userfileb,".shp",sep=""),mode=4) #-1 for bad, 0 for OK\par
\par
if(checkfile==0)\{#found shapefile\}\par
#if found good shapefile\par
\}else\{#else needs to be on the same line as bracket so R knows the statement continues\par
print("Sorry, couldn't find boundary shapefile")\par
guiDlgMessage("Sorry, couldn't find your boundary shapefile", title = "File error",type="ok",icon="error")\par
quit(save="no")\par
\}##end prompt user for point file\par
\par
#get boundary file\par
#find input file name and path\par
slashloc=max(unlist(gregexpr("/",userfileb,fixed=TRUE))) #find location of last slash, divides path and file name\par
userfileinb<-substr(userfileb,slashloc+1,nchar(userfileb))\par
userpathinb<-substr(userfileb,1,slashloc-1)\par
\par
mybound.shp<-readOGR(dsn=userpathinb,layer=userfileinb)\par
step<-2 \par
\par
#find if these maps are lat/long or not\par
#myproj<-proj4string(nytown.shp)=="+proj=longlat"\par
myproj<-grepl("longlat",proj4string(mypoints.shp),fixed=TRUE) #returns logical vector\par
myprojb<-grepl("longlat",proj4string(mybound.shp),fixed=TRUE) #returns logical vector\par
if(is.na(myproj))\{myproj<-FALSE\} #default to not lat/long if something goes wrong\par
if(is.na(myprojb))\{myprojb<-FALSE\} #default to not lat/long if something goes wrong\par
if(myproj==FALSE)\{guiDlgMessage("Sorry, the point file must be in latitude/longitude",title="Unsuitable Projection",type="ok",icon="error")\par
quit(save="no")\}\par
if(myprojb==FALSE)\{guiDlgMessage("Sorry, the boundary file must be in latitude/longitude",title="Unsuitable Projection",type="ok",icon="error")\par
quit(save="no")\}\par
#if projection is lat/lon, myproj=TRUE, otherwise FALSE\par
\par
\}#end step 1\par
\f0\par
if(step==2)\{userdist<-1000 #in meters, fornow\par
\par
\f1 setStatusBar(paste("NYSDOH Point Pertubation Tool: enter maximum distance to move points"))\f0\par
\par
\f1 userdistc<-gatInput(gatmessage=paste("Enter maximum distance:"), gattitle = "Maximum distance to move points", gatdefault = as.character(userdist),gathelpfile=paste("file://",getwd(),"/help/movepointshelp.html",sep=""),dd1choices=c("NONE",numlistitems),dd2choices=c("m","ft","km","mi"))\par
\par
if(userdistc[2]=="NONE")\{userdist<-as.numeric(userdistc[1])\}\par
else\{userdist<-mypoints.shp@data[,userdistc[2]]\}\par
\par
while(class(userdist)!="numeric"&&userdistc[1]!="go back")\{\par
userdistc<-gatInput(gatmessage = paste("Please reenter maximum distance to move points"), gattitle = "Maximum distance", gatdefault = "1000",gathelpfile=paste("file://",getwd(),"/help/movepointshelp.html",sep=""))\par
\}#end while\par
\par
#convert units to meters if needed\par
if(userdistc[3]=="km")\{userdist<-userdist*1000\}\par
if(userdistc[3]=="mi")\{userdist<-userdist*1609.344\}\par
if(userdistc[3]=="ft")\{userdist<-userdist/3.2808399\}\par
\par
if(userdistc[1]=="go back")\{step<-1\}else\{step<-3\}\par
\par
\}#end step 2\par
\par
if(step==3)\{\par
\par
setStatusBar(paste("NYSDOH Point Pertubation Tool: confirm your selections"))\par
\par
if(userdistc[2]=="NONE")\{mymessage<-paste("Do you want to move points from ",userfilein," a maximum distance of ",userdist[1],userdist[3]," but keep them within the boundaries of ",userfileinb,"?")\}\par
else\{\par
mymessage<-paste("Do you want to move points from ",userfilein," the maximum distance specified in the data field ",userdistc[2],"in", userdistc[3]," but keep them within the boundaries of ",userfileinb,"?")\}\par
\par
mycancel<-guiDlgMessage(mymessage,title=paste("Confirm your choices"),type="yesnocancel",icon="question")\par
\par
if(mycancel=="yes")\{step<-100\} #done with user input \par
if(mycancel=="no")\{step<-2\} #if no, go back a step\par
if(mycancel=="cancel")\{quit(save="no")\}\par
\}#end step 3, confirmation\par
\} #end the while step<100\par
\f0\par
\f1\par
#now, want to display the points\par
#will want to confirm that the class is "SpatialPointsDataFrame" for mypoints.shp\par
#class of mybound.shp is "SpatialPolygonsDataFrame"\par
\par
plot(mybound.shp)\par
points(mypoints.shp, pch=21, col="black",bg="red") #produces red circles outlined in black\par
#title("Points before moving")\par
\par
npoints<-nrow(mypoints.shp)\par
newdis<-runif(npoints,min=0,max=userdist)\par
newang<-runif(npoints,min=0,max=2*pi)\par
\par
#formulas to move points\par
\cf1\f2 #for y: \f3 original latitude+ SIN(r1*2*PI())*r2*500/111000\par
\f2 #for x: \f3 original longitude+COS(r1*2*PI())*r2*500)/(COS(RADIANS(original lat))*111321)\par
\par
\f2 mycoords<-coordinates(mypoints.shp)\par
#coordinates of areas gives label points, one for each area\par
myx<-mycoords[,1]\par
myy<-mycoords[,2]\par
\par
#make sure arguments of sin/cosine are in radians.  \par
mynewy<-myy+sin(newang)*newdis/111000  #approx 111 km per degree latitude\par
mynewx<-myx+cos(newang)*newdis/(cos(myy*pi/180)*111321)\par
\par
#now, also need to get coordinates for polygons, and check if points are inside\par
x<-length(mybound.shp@polygons)\par
for(n in 1:x)\{\par
myp<-mybound.shp@polygons[[n]] #here '1' is the first polygon in the shapefile (can loop through), 9 is albany for my example data\par
myp2<-myp@Polygons[[1]]\par
mypc<-myp2@coords\par
mypx<-mypc[,1]\par
mypy<-mypc[,2]\par
#check if points are in polygon.  0=exterior, 1=interior, 2&3 are on edge/vertex\par
checkifin<-point.in.polygon(myx,myy,mypx,mypy)\par
checkifnewin<-point.in.polygon(mynewx,mynewy,mypx,mypy)\par
print(c(n,checkifin,checkifnewin))\par
\par
#if the old point is in an area, but the new point is not, need to fix it\par
y<-length(checkifin)\par
for(p in 1:y)\{\par
if(checkifin[p]>1)\{checkifin[p]<-1\} #treat edges as interior\par
if(checkifnewin[p]>1)\{checkifnewin[p]<-1\}\par
shorterdist<-userdist\par
while(checkifin[p]==1&&checkifnewin[p]==0)\{print(c("need to fix ",p))\par
shorterdist<-shorterdist-shorterdist*0.1  #if the point falls outside the area, decrease the maximum distance by 10% each time we cycle through\par
\cf0\f1 newdis[p]<-runif(1,min=0,max=shorterdist)\par
newang[p]<-runif(1,min=0,max=2*pi)\par
\cf1\f2 mynewy[p]<-myy[p]+sin(newang[p])*newdis[p]/111000  #approx 111 km per degree latitude\par
mynewx[p]<-myx[p]+cos(newang[p])*newdis[p]/(cos(myy[p]*pi/180)*111321)\par
checkifnewin[p]<-point.in.polygon(mynewx[p],mynewy[p],mypx,mypy)\par
if(checkifnewin[p]>1)\{checkifnewin[p]<-1\}\par
\}#for discrepant points\par
\}#after cycling through number of points\par
\}#cycle through all areas\par
\par
\par
mynewcoords<-data.frame(mynewx,mynewy)\par
mydata<-data.frame(mypoints.shp)\par
coordinates(mydata)<-mynewcoords\par
proj4string(mydata)<-proj4string(mypoints.shp) #assign original projection to new points\par
\par
\cf0\f1 #dev.new()\par
#use points to add new data to same plot\cf1\f2\par
\cf0\f1 points(mydata, pch=24, col="black",bg="blue") #produces green triangles outlined in black\par
title("Points before and after moving")\par
legend(x="topleft",legend=c("before","after"),horiz=FALSE,pch=c(21,24),col=c("black","black"),pt.bg=c("red","blue"))\par
\par
userfileout<-"" #set as default missing\par
setStatusBar(paste("NYSDOH Point Pertubation Tool: save file"))\par
\par
while(userfileout=="")\{\par
userout<-guiDlgSave(title = "Save Moved Points As", defaultFile = "", defaultDir = "",defaultExt = "", filters = c("Shapefiles (*.shp)", "*.shp"))\par
#now remove any file extention\par
periodloc=regexpr(".",userout,fixed=TRUE) #will be -1 if no match, otherwise location(s) of matches\par
if(periodloc>0)\{userout<-substr(userout,1,periodloc[1]-1)\}\par
\par
#find output file name and path\par
slashloc<-max(unlist(gregexpr("/",userout,fixed=TRUE))) #find location of last slash, divides path and file name\par
userfileout<-substr(userout,slashloc+1,nchar(userout))\par
userpathout<-substr(userout,1,slashloc-1)\par
#filename shouldn't contain ;=+<>|"[]/\\'<>:*?\par
\par
checkfile<-regexpr(";|:|\\\\+|=|<|>|\\\\||\\\\[|\\\\]|/|\\"|'|\\\\*|\\\\?\\n",userfileout,perl=TRUE)\par
if(checkfile[1]!="-1")\{userfileout<-""\}\par
\par
checkfile<-charmatch("\\\\",userfileout,nomatch=-1)\par
if(checkfile[1]!="-1")\{userfileout<-""\}\par
\par
if(userfileout=="")\{\par
guiDlgMessage("Your file name may have been invalid.  Please reenter your file name.",title="WARNING", type="ok")\}\par
\} #end while no good file name\par
\par
#userpathout<-"E:/testdata"\par
#userfileout<-"movedpoints"\par
\par
#change names of old coordinates\par
names(mydata)[names(mydata)=="coords.x1"]<-"prev_x" #change the name of the old coordinates\par
names(mydata)[names(mydata)=="coords.x2"]<-"prev_y" #change the name of the old coordinates\par
\par
#write  out shapefile using OGR\par
#output file doesn't seem to have projection\par
writeOGR(mydata, userpathout, userfileout, driver="ESRI Shapefile",verbose=FALSE) #seems fast\par
\par
kmlfilename<-paste(userpathout,paste(userfileout,"kml",sep="."),sep="/")\par
#for KML need writeOGR(object,fileName,layerName,driver="KML") \par
#where layer name will be distplayed in layer list of Google Earth\par
mykmlnames<-paste("NameField=",names(mydata)[1],sep="") #default to use the first field as ID\par
writeOGR(mydata,kmlfilename,"moved_points", driver="KML",dataset_options=mykmlnames,verbose=FALSE)\par
#might be able to specifcy NameField, DescriptionField, AltitudeMode\par
#NameField=mydata@data[1]\par
writeOGR(mydata, userpathout, userfileout, driver="MapInfo File",verbose=FALSE) #seems fast\par
\par
setStatusBar(paste("NYSDOH Point Pertubation Tool: find your results in: ",userpathout))\par
\par
\par
\par
\par
\par
\f0\par
}
 