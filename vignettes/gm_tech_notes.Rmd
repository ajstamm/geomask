---
title: "Geomasker Technical Notes"
author: "Abigail Stamm, Thomas Talbot, and Gwen Babcock"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 3
    number_sections: true
vignette: >
  %\VignetteIndexEntry{Technical Notes}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE, warning = FALSE, message = FALSE, 
                      echo = FALSE, comment = "#>")
```


# Geomasker Overview

This package is maintained by the New York State Department of Health (NYSDOH) Environmental Public Health Tracking (EPHT) program. The purpose of this package is to run the geomasker in R. The purpose of the geomasker is to move points randomly within a circular region around each point. This could be used to preserve confidentiality in publicly released point maps.


The input object is a shapefile (*.shp). For shapefile requirements, see [Preparing your shapefile for geomasking](prepare_shapefile.html). At minimum, the geomasker requires a point shapefile with an identifying variable and a polygon shapefile for area boundaries. 

<!-- any minimum? or any shapefile? allow no boundaries (so person can be put in a lake or another state)? -->

A series of dialog boxes allows the user to select a variable to uniquely identify areas, a boundary file, and minimum and maximum distances. The geomasker requires a boundary shapefile to restrict the movement of points so that all of the new points remain within the same boundaries as the old points. This ensures, for example, that points are not moved into water bodies and that they remain within the same political boundaries.

The output includes: a revised version of the original shapefile with masked point coordinates, a new shapefile that maps to the revised coordinates, a shapefile of the buffers used to select points, a PDF with a map comparing points, a comprehensive log, and if requested a KML file. The shapefile can be read in ArcGIS, MapInfo, and QGIS. The KML file can be displayed in Google Earth and other Internet-based mapping programs.

The package does not include any embedded shapefiles. It uses map layers in the `tigris` package for all examples. 



# How the geomasker selects masked points

```{r examplebuffer, warning = FALSE, message = FALSE, echo = FALSE, include = FALSE}
# load data
b <- tigris::block_groups("NY", "Onondaga", 2010)
c <- b |> dplyr::filter(grepl(36067011401, GEOID))
p <- tigris::landmarks("NY", "point", year = 2015)
t <- t <- sf::st_contains(c, p) |> unlist()
q <- p[t, ]

# create buffers
bufmin <- sf::st_buffer(q, 500)
bufmax <- sf::st_buffer(q, 1000)
diff <- sf::st_difference(bufmax, sf::st_combine(bufmin), model = "closed")

# limit buffers to relevant geographies
int <- sf::st_intersection(q, c)
poly <- dplyr::filter(c, GEOID %in% int$GEOID)
d <- sf::st_intersection(diff, poly)

# shift points
shift <- sf::st_as_sf(sf::st_sample(d, size = rep(1, nrow(d)), 
                                    by_polygon = TRUE), 
                      crs = sf::st_crs(c))


```

The geomasker reads in point data and identifies the boundary polygon in which the point falls.

```{r point, fig.cap = 'Block groups with landmark points, Onondaga County, NY', warning = FALSE, message = FALSE}
graphics::par(mar = c(0,0,0,0)+.1, mgp = c(0,0,0)) # bottom, left, top, right


plot(sf::st_geometry(c), border = "green", col = "transparent",
     lty = "solid", lwd = 1)
plot(sf::st_geometry(q), col = "blue", pch = 20, add = TRUE)




```

<!-- what if there are no valid points in the buffer? -->

The geomasker creates a buffer around the point using the user-defined minimum distance to draw the inner ring and the user-defined maximum distance to draw the outer ring. 

```{r buffer, warning = FALSE, message = FALSE, fig.cap = 'Block groups with landmark points and buffers, Onondaga County, NY'}
graphics::par(mar = c(0,0,0,0)+.1, mgp = c(0,0,0)) # bottom, left, top, right

plot(sf::st_geometry(diff), col = "yellow", border = "orange")
plot(sf::st_geometry(c), border = "green", col = "transparent",
     lty = "solid", lwd = 1, add = TRUE)
plot(sf::st_geometry(q), col = "blue", pch = 20, add = TRUE)


```

The geomasker intersects the buffers with the boundary associated with their respective points. The valid sampling areas are below, outlined in cyan. 

```{r valid, warning = FALSE, message = FALSE, fig.cap = 'Block groups with landmark points, buffers, and valid sampling areas, Onondaga County, NY'}
graphics::par(mar = c(0,0,0,0)+.1, mgp = c(0,0,0)) # bottom, left, top, right


plot(sf::st_geometry(diff), col = "transparent", border = "orange")
plot(sf::st_geometry(c), border = "green", col = "transparent",
     lty = "solid", lwd = 1, add = TRUE)
plot(sf::st_geometry(poly), border = "red", col = "ivory",
     lty = "solid", lwd = 1, add = TRUE)
plot(sf::st_geometry(d), col = "yellow", border = "cyan", lwd = 2, add = TRUE)
plot(sf::st_geometry(q), col = "blue", pch = 20, add = TRUE)


```

The geomasker selects a random point inside each valid area. Subsequent loops will cycle through points without valid areas until a valid area is drawn and a new point is randomly selected. Shifted points are red below.


```{r shifted, warning = FALSE, message = FALSE, fig.cap = 'Block groups with landmark points, buffers, valid areas, and shifted points, Onondaga County, NY'}

graphics::par(mar = c(0,0,0,0)+.1, mgp = c(0,0,0)) # bottom, left, top, right



plot(sf::st_geometry(diff), col = "transparent", border = "orange")
plot(sf::st_geometry(c), border = "green", col = "transparent",
     lty = "solid", lwd = 1, add = TRUE)
plot(sf::st_geometry(q), col = "blue", pch = 20, add = TRUE)
plot(sf::st_geometry(d), col = "yellow", border = "cyan", lwd = 2, add = TRUE)
plot(sf::st_geometry(shift), col = "red", pch = 20, add = TRUE)


```




# Variables created by the geomasker


- **point_id:** duplicate of the original locations identifier
- **bound_id:** duplicate of the boundaries identifier
- **orig_lat:** original location latitude as calculated by R
- **orig_lon:** original location longitude as calculated by R
- **mask_lat:** shifted or masked location latitude as calculated by R
- **mask_lon:** shifted or masked location longitude as calculated by R
- **flag:** number of times buffers had to be recalculated to create a valid area

For the flag variable, the lowest possible value is 0, which means that when intersecting a buffer using the user-defined minimum and maximum distances with the boundary polygon, a valid area was created from which to select a sample point. There is no highest possible value, but the higher the flag value, the narrower the buffer created and the closer the masked point will be to the original point. Each time the process fails to create a valid area, the maximum and minimum distances for the ring are recalculated. The old minimum value becomes the new maximum value and the new minimum value is assigned half the new maximum value. 

Users should review any point with a flag value greater than 0. The "*_buffer" shapefile is provided so users can see the exact areas sampled to generate the masked points. This shapefile includes the "point_id" variable so users can link points and buffers easily.







