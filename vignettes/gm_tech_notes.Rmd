---
title: "Geomasker Technical Notes"
author: "Abigail Stamm, Thomas Talbot, and Gwen Babcock"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 3
    number_sections: true
vignette: >
  %\VignetteIndexEntry{GAT Technical Notes}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


# Geomasker Overview

This package is maintained by the New York State Department of Health (NYSDOH) Environmental Public Health Tracking (EPHT) program. The purpose of this package is to run the geomasker in R. 

The purpose of the geomasker is to move points randomly within a circular region around each point. This could be used to preserve confidentiality in publicly released point maps.

The input object is a shapefile (*.shp). For shapefile requirements, see [Preparing your shapefile for geomasking](prepare_shapefile.html). At minimum, the geomasker requires a point shapefile with an identifying variable and a polygon shapefile for area boundaries. 

<!-- any minimum? or any shapefile? allow no boundaries (so person can be put in a lake or another state)? -->

A series of dialog boxes allows the user to select a variable to uniquely identify areas, a boundary file, and minimum and maximum distances. The geomasker requires a boundary shapefile to restrict the movement of points so that all of the new points remain within the same boundaries as the old points. This ensures, for example, that points are not moved into water bodies or that they remain within the same political boundaries.

The output includes: a revised version of the original shapefile with masked point coordinates, a new shapefile that maps to the revised coordinates, a shapefile of the buffers used to select points, a PDF with a map comparing points, a comprehensive log, and if requested a KML file. The shapefile can be read in ArcGIS, MapInfo, and QGIS. The KML file can be displayed in Google Earth and other Internet-based mapping programs.

The package does not include any embedded shapefiles. It uses the tigris package for all examples. 



# How the geomasker selects masked points

The geomasker reads in point data and identifies the boundary polygon in which the point falls.

```{r point}
b <- tigris::blocks("NY", "Onondaga", 2010)
c <- b |> dplyr::filter(grepl(36067011401, GEOID10))
p <- tigris::landmarks("NY", "point", year = 2015)
t <- t <- sf::st_contains(c, p) |> unlist()
q <- p[t, ]

plot(sf::st_geometry(c), border = "green", col = "transparent",
     lty = "solid", lwd = 1)
plot(sf::st_geometry(q), col = "blue", pch = 20, add = TRUE)




```

<!-- what if there are no valid points in the buffer? -->

The geomasker creates a ring around the point using the user-defined minimum distance to create the inner ring and the user-defined maximum distance to calculate the outer ring.

```{r buffer}

bufmin <- sf::st_buffer(q, 500)
bufmax <- sf::st_buffer(q, 1000)
diff <- sf::st_difference(bufmax, sf::st_combine(bufmin), model = "closed")

plot(sf::st_geometry(diff), col = "yellow", border = "orange")
plot(sf::st_geometry(c), border = "green", col = "transparent",
     lty = "solid", lwd = 1, add = TRUE)
plot(sf::st_geometry(q), col = "blue", pch = 20, add = TRUE)


```

The geomasker intersects the buffer with the boundary associated with the point. The valid buffer below is outlined in cyan. The yellow area at the top does not intersect the buffer, so it is not valid.

```{r buffer, warnings = FALSE}

int <- sf::st_intersection(q, c)
poly <- dplyr::filter(c, GEOID10 %in% int$GEOID10)
d <- sf::st_intersection(diff, poly)

plot(sf::st_geometry(c), border = "green", col = "transparent",
     lty = "solid", lwd = 1)
plot(sf::st_geometry(poly), border = "red", col = "yellow",
     lty = "solid", lwd = 1, add = TRUE)
plot(sf::st_geometry(diff), col = "transparent", border = "orange", add = TRUE)
plot(sf::st_geometry(q[2, ]), col = "blue", pch = 20, add = TRUE)
plot(sf::st_geometry(d), col = "orange", border = "cyan", lwd = 2, add = TRUE)


```

Continuing with the lower point with the valid buffer, the geomasker selects a random point inside the intersected area. Subsequent loops will cycle through the second point until a valid area is created. A point will be randomly selected from the eventual valid area.


```{r buffer}
shift <- sf::st_as_sf(sf::st_sample(d, 1), crs = sf::st_crs(c))




plot(sf::st_geometry(diff), col = "transparent", border = "orange")
plot(sf::st_geometry(c), border = "green", col = "transparent",
     lty = "solid", lwd = 1, add = TRUE)
plot(sf::st_geometry(q), col = "blue", pch = 20, add = TRUE)
plot(sf::st_geometry(d), col = "orange", border = "cyan", lwd = 2, add = TRUE)
plot(sf::st_geometry(shift), col = "purple", pch = 20, add = TRUE)


```




# Variables created by the geomasker


- **point_id:** duplicate of the original locations identifier
- **bound_id:** duplicate of the boundaries identifier
- **orig_lat:** original location latitude as calculated by R
- **orig_lon:** original location longitude as calculated by R
- **mask_lat:** shifted or masked location latitude as calculated by R
- **mask_lon:** shifted or masked location longitude as calculated by R
- **flag:** number of times buffers had to be recalculated to create a valid area

For the flag variable, the lowest possible value is 0, which means that when intersecting a buffer using the user-defined minimum and maximum distances with the boundary polygon, a valid area was created from which to select a sample point. There is no highest possible value, but the higher the flag value, the narrower the buffer created and the closer the masked point will be to the original point. Each time the process fails to create a valid area, the maximum and minimum distances for the ring are recalculated. The new maximum value becomes the old minimum value and the new minimum value becomes half the new maximum value. You should review any point with a flag value greater than 0.









